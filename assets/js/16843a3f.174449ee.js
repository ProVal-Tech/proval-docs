"use strict";(self.webpackChunkproval_docs=self.webpackChunkproval_docs||[]).push([[30449],{484795:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"cwa/scripts/70f5868c-7006-4393-afed-156fbae86ab5","title":"Remote Monitor - Emulate Send Fail After Success","description":"This document describes an autofix solution for remote monitors that enables them to mimic the behavior of internal monitors by allowing automatic ticket closure based on monitor status changes. It includes details on dependencies, variables, and the processing logic of the script.","source":"@site/docs/cwa/scripts/Remote Monitor - Emulate Send Fail After Success.md","sourceDirName":"cwa/scripts","slug":"/cwa/scripts/70f5868c-7006-4393-afed-156fbae86ab5","permalink":"/docs/cwa/scripts/70f5868c-7006-4393-afed-156fbae86ab5","draft":false,"unlisted":false,"editUrl":"https://github.com/proval-tech/proval-docs/tree/main/docs/cwa/scripts/Remote Monitor - Emulate Send Fail After Success.md","tags":[],"version":"current","frontMatter":{"id":"70f5868c-7006-4393-afed-156fbae86ab5","title":"Remote Monitor - Emulate Send Fail After Success","title_meta":"Remote Monitor - Emulate Send Fail After Success","keywords":["remote","monitor","ticket","management","autofix","status"],"description":"This document describes an autofix solution for remote monitors that enables them to mimic the behavior of internal monitors by allowing automatic ticket closure based on monitor status changes. It includes details on dependencies, variables, and the processing logic of the script.","tags":[],"draft":false,"unlisted":false},"sidebar":"contentSidebar","previous":{"title":"Remote Event Log Monitor - Create","permalink":"/docs/cwa/scripts/144d7d52-8764-4aa4-bcce-205c756f6203"},"next":{"title":"Remove - All But My - ScreenConnect Client Installations","permalink":"/docs/cwa/scripts/50779f68-4329-4d15-b069-c50fcba00614"}}');var n=i(474848),o=i(28453);const r={id:"70f5868c-7006-4393-afed-156fbae86ab5",title:"Remote Monitor - Emulate Send Fail After Success",title_meta:"Remote Monitor - Emulate Send Fail After Success",keywords:["remote","monitor","ticket","management","autofix","status"],description:"This document describes an autofix solution for remote monitors that enables them to mimic the behavior of internal monitors by allowing automatic ticket closure based on monitor status changes. It includes details on dependencies, variables, and the processing logic of the script.",tags:[],draft:!1,unlisted:!1},a=void 0,c={},l=[{value:"Summary",id:"summary",level:2},{value:"Sample Run",id:"sample-run",level:2},{value:"Dependencies",id:"dependencies",level:2},{value:"Variables",id:"variables",level:2},{value:"Script States",id:"script-states",level:4},{value:"Process",id:"process",level:2},{value:"Output",id:"output",level:2}];function d(e){const t={br:"br",code:"code",h2:"h2",h4:"h4",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,n.jsx)(t.p,{children:'Remote monitors do not have the ability to perform "Send fail after success" style actions like internal monitors do. This autofix will help a remote monitor behave more like an internal monitor. This "autofix" should be implemented in scenarios where a client would like to use "Default - Create Automate Ticket" but allow for the ticket to automatically close if the remote monitor changes statuses. Note that this is a function script and cannot be run manually. This script is also an offline machine script, meaning it can run even if the agent is offline.'}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Time Saved by Automation:"})," 5 Minutes"]}),"\n",(0,n.jsx)(t.h2,{id:"sample-run",children:"Sample Run"}),"\n",(0,n.jsx)(t.p,{children:"This script should not be run manually and will fail if it is forced to run manually."}),"\n",(0,n.jsx)(t.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,n.jsx)(t.p,{children:"This script requires a remote monitor to function properly."}),"\n",(0,n.jsx)(t.h2,{id:"variables",children:"Variables"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"@Ticketid@"})," - This variable is either populated with previous ticket ID information or will gather data from the script state to be used in this script. It is the ticket ID the script is using to take action."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"@agentid@"})," - This is the database ID number of the monitor used to track which monitor generated the ticket."]}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"script-states",children:"Script States"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Name"}),(0,n.jsx)(t.th,{children:"Example"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"AgentID"}),(0,n.jsx)(t.td,{children:"123456"}),(0,n.jsx)(t.td,{children:"This is the database ID number of the monitor used to track which monitor generated the ticket."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"TicketID"}),(0,n.jsx)(t.td,{children:"123456"}),(0,n.jsx)(t.td,{children:"This variable is either populated with previous ticket ID information or will gather data from the script state to be used in this script. It is the ticket ID the script is using to take action."})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"process",children:"Process"}),"\n",(0,n.jsx)(t.p,{children:'First, the script will determine if the monitor issuing the script is reporting "success" or "failure." If the script evaluates the monitor as "Failed," it will proceed to the Then section. If the monitor is "successful," the script will go to the Else section.'}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Then section"}),(0,n.jsx)(t.br,{}),"\n","The script will first check if there is an open ticket related to the situation detected by the monitor. If the ticket exists, the script will jump to the existing ticket section and update the ticket with a comment. This comment should include the latest result from the monitor. If the ticket number does not exist, the script will generate a ticket with the available data from the remote monitor."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Else section"}),(0,n.jsx)(t.br,{}),"\n",'If the script determines the monitor is in a "success" state, it will go through the Else section. In the Else section, the script will first check if the script state ticket number exists. If a ticket exists, the script will close the ticket, indicating that the monitor has returned to "Success," so the ticket was safe to close. If there was no ticket, the script will simply exit.']}),"\n",(0,n.jsx)(t.h2,{id:"output",children:"Output"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Script log messages"})}),"\n",(0,n.jsx)(t.p,{children:"The script will create a ticket if necessary."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>a});var s=i(296540);const n={},o=s.createContext(n);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);